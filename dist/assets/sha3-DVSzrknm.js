var d={},c={},K;function Z(){if(K)return c;K=1,Object.defineProperty(c,"__esModule",{value:!0}),c.toBig=c.shrSL=c.shrSH=c.rotrSL=c.rotrSH=c.rotrBL=c.rotrBH=c.rotr32L=c.rotr32H=c.rotlSL=c.rotlSH=c.rotlBL=c.rotlBH=c.add5L=c.add5H=c.add4L=c.add4H=c.add3L=c.add3H=void 0,c.add=A,c.fromBig=I,c.split=H;const o=BigInt(2**32-1),l=BigInt(32);function I(n,e=!1){return e?{h:Number(n&o),l:Number(n>>l&o)}:{h:Number(n>>l&o)|0,l:Number(n&o)|0}}function H(n,e=!1){const r=n.length;let p=new Uint32Array(r),g=new Uint32Array(r);for(let b=0;b<r;b++){const{h:P,l:C}=I(n[b],e);[p[b],g[b]]=[P,C]}return[p,g]}const O=(n,e)=>BigInt(n>>>0)<<l|BigInt(e>>>0);c.toBig=O;const X=(n,e,r)=>n>>>r;c.shrSH=X;const j=(n,e,r)=>n<<32-r|e>>>r;c.shrSL=j;const R=(n,e,r)=>n>>>r|e<<32-r;c.rotrSH=R;const T=(n,e,r)=>n<<32-r|e>>>r;c.rotrSL=T;const U=(n,e,r)=>n<<64-r|e>>>r-32;c.rotrBH=U;const v=(n,e,r)=>n>>>r-32|e<<64-r;c.rotrBL=v;const x=(n,e)=>e;c.rotr32H=x;const q=(n,e)=>n;c.rotr32L=q;const M=(n,e,r)=>n<<r|e>>>32-r;c.rotlSH=M;const S=(n,e,r)=>e<<r|n>>>32-r;c.rotlSL=S;const m=(n,e,r)=>e<<r-32|n>>>64-r;c.rotlBH=m;const E=(n,e,r)=>n<<r-32|e>>>64-r;c.rotlBL=E;function A(n,e,r,p){const g=(e>>>0)+(p>>>0);return{h:n+r+(g/2**32|0)|0,l:g|0}}const k=(n,e,r)=>(n>>>0)+(e>>>0)+(r>>>0);c.add3L=k;const B=(n,e,r,p)=>e+r+p+(n/2**32|0)|0;c.add3H=B;const a=(n,e,r,p)=>(n>>>0)+(e>>>0)+(r>>>0)+(p>>>0);c.add4L=a;const i=(n,e,r,p,g)=>e+r+p+g+(n/2**32|0)|0;c.add4H=i;const u=(n,e,r,p,g)=>(n>>>0)+(e>>>0)+(r>>>0)+(p>>>0)+(g>>>0);c.add5L=u;const f=(n,e,r,p,g,b)=>e+r+p+g+b+(n/2**32|0)|0;c.add5H=f;const h={fromBig:I,split:H,toBig:O,shrSH:X,shrSL:j,rotrSH:R,rotrSL:T,rotrBH:U,rotrBL:v,rotr32H:x,rotr32L:q,rotlSH:M,rotlSL:S,rotlBH:m,rotlBL:E,add:A,add3L:k,add3H:B,add4L:a,add4H:i,add5H:f,add5L:u};return c.default=h,c}var N={},V={},z;function $(){return z||(z=1,Object.defineProperty(V,"__esModule",{value:!0}),V.crypto=void 0,V.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0),V}var G;function tt(){return G||(G=1,function(o){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(o,"__esModule",{value:!0}),o.wrapXOFConstructorWithOpts=o.wrapConstructorWithOpts=o.wrapConstructor=o.Hash=o.nextTick=o.swap32IfBE=o.byteSwapIfBE=o.swap8IfBE=o.isLE=void 0,o.isBytes=I,o.anumber=H,o.abytes=O,o.ahash=X,o.aexists=j,o.aoutput=R,o.u8=T,o.u32=U,o.clean=v,o.createView=x,o.rotr=q,o.rotl=M,o.byteSwap=S,o.byteSwap32=m,o.bytesToHex=k,o.hexToBytes=i,o.asyncLoop=f,o.utf8ToBytes=h,o.bytesToUtf8=n,o.toBytes=e,o.kdfInputToBytes=r,o.concatBytes=p,o.checkOpts=g,o.createHasher=P,o.createOptHasher=C,o.createXOFer=F,o.randomBytes=Q;const l=$();function I(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function H(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function O(t,...s){if(!I(t))throw new Error("Uint8Array expected");if(s.length>0&&!s.includes(t.length))throw new Error("Uint8Array expected of length "+s+", got length="+t.length)}function X(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");H(t.outputLen),H(t.blockLen)}function j(t,s=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(s&&t.finished)throw new Error("Hash#digest() has already been called")}function R(t,s){O(t);const y=s.outputLen;if(t.length<y)throw new Error("digestInto() expects output buffer of length at least "+y)}function T(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function U(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function v(...t){for(let s=0;s<t.length;s++)t[s].fill(0)}function x(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function q(t,s){return t<<32-s|t>>>s}function M(t,s){return t<<s|t>>>32-s>>>0}o.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function S(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}o.swap8IfBE=o.isLE?t=>t:t=>S(t),o.byteSwapIfBE=o.swap8IfBE;function m(t){for(let s=0;s<t.length;s++)t[s]=S(t[s]);return t}o.swap32IfBE=o.isLE?t=>t:m;const E=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",A=Array.from({length:256},(t,s)=>s.toString(16).padStart(2,"0"));function k(t){if(O(t),E)return t.toHex();let s="";for(let y=0;y<t.length;y++)s+=A[t[y]];return s}const B={_0:48,_9:57,A:65,F:70,a:97,f:102};function a(t){if(t>=B._0&&t<=B._9)return t-B._0;if(t>=B.A&&t<=B.F)return t-(B.A-10);if(t>=B.a&&t<=B.f)return t-(B.a-10)}function i(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(E)return Uint8Array.fromHex(t);const s=t.length,y=s/2;if(s%2)throw new Error("hex string expected, got unpadded hex of length "+s);const w=new Uint8Array(y);for(let L=0,_=0;L<y;L++,_+=2){const D=a(t.charCodeAt(_)),W=a(t.charCodeAt(_+1));if(D===void 0||W===void 0){const Y=t[_]+t[_+1];throw new Error('hex string expected, got non-hex character "'+Y+'" at index '+_)}w[L]=D*16+W}return w}const u=async()=>{};o.nextTick=u;async function f(t,s,y){let w=Date.now();for(let L=0;L<t;L++){y(L);const _=Date.now()-w;_>=0&&_<s||(await(0,o.nextTick)(),w+=_)}}function h(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function n(t){return new TextDecoder().decode(t)}function e(t){return typeof t=="string"&&(t=h(t)),O(t),t}function r(t){return typeof t=="string"&&(t=h(t)),O(t),t}function p(...t){let s=0;for(let w=0;w<t.length;w++){const L=t[w];O(L),s+=L.length}const y=new Uint8Array(s);for(let w=0,L=0;w<t.length;w++){const _=t[w];y.set(_,L),L+=_.length}return y}function g(t,s){if(s!==void 0&&{}.toString.call(s)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(t,s)}class b{}o.Hash=b;function P(t){const s=w=>t().update(e(w)).digest(),y=t();return s.outputLen=y.outputLen,s.blockLen=y.blockLen,s.create=()=>t(),s}function C(t){const s=(w,L)=>t(L).update(e(w)).digest(),y=t({});return s.outputLen=y.outputLen,s.blockLen=y.blockLen,s.create=w=>t(w),s}function F(t){const s=(w,L)=>t(L).update(e(w)).digest(),y=t({});return s.outputLen=y.outputLen,s.blockLen=y.blockLen,s.create=w=>t(w),s}o.wrapConstructor=P,o.wrapConstructorWithOpts=C,o.wrapXOFConstructorWithOpts=F;function Q(t=32){if(l.crypto&&typeof l.crypto.getRandomValues=="function")return l.crypto.getRandomValues(new Uint8Array(t));if(l.crypto&&typeof l.crypto.randomBytes=="function")return Uint8Array.from(l.crypto.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}}(N)),N}var J;function et(){if(J)return d;J=1,Object.defineProperty(d,"__esModule",{value:!0}),d.shake256=d.shake128=d.keccak_512=d.keccak_384=d.keccak_256=d.keccak_224=d.sha3_512=d.sha3_384=d.sha3_256=d.sha3_224=d.Keccak=void 0,d.keccakP=E;const o=Z(),l=tt(),I=BigInt(0),H=BigInt(1),O=BigInt(2),X=BigInt(7),j=BigInt(256),R=BigInt(113),T=[],U=[],v=[];for(let a=0,i=H,u=1,f=0;a<24;a++){[u,f]=[f,(2*u+3*f)%5],T.push(2*(5*f+u)),U.push((a+1)*(a+2)/2%64);let h=I;for(let n=0;n<7;n++)i=(i<<H^(i>>X)*R)%j,i&O&&(h^=H<<(H<<BigInt(n))-H);v.push(h)}const x=(0,o.split)(v,!0),q=x[0],M=x[1],S=(a,i,u)=>u>32?(0,o.rotlBH)(a,i,u):(0,o.rotlSH)(a,i,u),m=(a,i,u)=>u>32?(0,o.rotlBL)(a,i,u):(0,o.rotlSL)(a,i,u);function E(a,i=24){const u=new Uint32Array(10);for(let f=24-i;f<24;f++){for(let e=0;e<10;e++)u[e]=a[e]^a[e+10]^a[e+20]^a[e+30]^a[e+40];for(let e=0;e<10;e+=2){const r=(e+8)%10,p=(e+2)%10,g=u[p],b=u[p+1],P=S(g,b,1)^u[r],C=m(g,b,1)^u[r+1];for(let F=0;F<50;F+=10)a[e+F]^=P,a[e+F+1]^=C}let h=a[2],n=a[3];for(let e=0;e<24;e++){const r=U[e],p=S(h,n,r),g=m(h,n,r),b=T[e];h=a[b],n=a[b+1],a[b]=p,a[b+1]=g}for(let e=0;e<50;e+=10){for(let r=0;r<10;r++)u[r]=a[e+r];for(let r=0;r<10;r++)a[e+r]^=~u[(r+2)%10]&u[(r+4)%10]}a[0]^=q[f],a[1]^=M[f]}(0,l.clean)(u)}class A extends l.Hash{constructor(i,u,f,h=!1,n=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=i,this.suffix=u,this.outputLen=f,this.enableXOF=h,this.rounds=n,(0,l.anumber)(f),!(0<i&&i<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,l.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,l.swap32IfBE)(this.state32),E(this.state32,this.rounds),(0,l.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(i){(0,l.aexists)(this),i=(0,l.toBytes)(i),(0,l.abytes)(i);const{blockLen:u,state:f}=this,h=i.length;for(let n=0;n<h;){const e=Math.min(u-this.pos,h-n);for(let r=0;r<e;r++)f[this.pos++]^=i[n++];this.pos===u&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:i,suffix:u,pos:f,blockLen:h}=this;i[f]^=u,(u&128)!==0&&f===h-1&&this.keccak(),i[h-1]^=128,this.keccak()}writeInto(i){(0,l.aexists)(this,!1),(0,l.abytes)(i),this.finish();const u=this.state,{blockLen:f}=this;for(let h=0,n=i.length;h<n;){this.posOut>=f&&this.keccak();const e=Math.min(f-this.posOut,n-h);i.set(u.subarray(this.posOut,this.posOut+e),h),this.posOut+=e,h+=e}return i}xofInto(i){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(i)}xof(i){return(0,l.anumber)(i),this.xofInto(new Uint8Array(i))}digestInto(i){if((0,l.aoutput)(i,this),this.finished)throw new Error("digest() was already called");return this.writeInto(i),this.destroy(),i}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,l.clean)(this.state)}_cloneInto(i){const{blockLen:u,suffix:f,outputLen:h,rounds:n,enableXOF:e}=this;return i||(i=new A(u,f,h,e,n)),i.state32.set(this.state32),i.pos=this.pos,i.posOut=this.posOut,i.finished=this.finished,i.rounds=n,i.suffix=f,i.outputLen=h,i.enableXOF=e,i.destroyed=this.destroyed,i}}d.Keccak=A;const k=(a,i,u)=>(0,l.createHasher)(()=>new A(i,a,u));d.sha3_224=k(6,144,224/8),d.sha3_256=k(6,136,256/8),d.sha3_384=k(6,104,384/8),d.sha3_512=k(6,72,512/8),d.keccak_224=k(1,144,224/8),d.keccak_256=k(1,136,256/8),d.keccak_384=k(1,104,384/8),d.keccak_512=k(1,72,512/8);const B=(a,i,u)=>(0,l.createXOFer)((f={})=>new A(i,a,f.dkLen===void 0?u:f.dkLen,!0));return d.shake128=B(31,168,128/8),d.shake256=B(31,136,256/8),d}export{tt as a,Z as b,et as r};
